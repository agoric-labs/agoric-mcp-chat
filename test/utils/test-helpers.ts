/**
 * Test Helpers for Integration Tests
 * Provides reusable utilities for API testing without database
 */

import { type UIMessage } from 'ai';
import { nanoid } from 'nanoid';

/**
 * Generate a test user ID
 */
export function generateTestUserId(): string {
  return `test-user-${nanoid()}`;
}

/**
 * Generate a test chat ID
 */
export function generateTestChatId(): string {
  return `test-chat-${nanoid()}`;
}

/**
 * Create a user message in UIMessage format
 */
export function createUserMessage(content: string, id?: string): UIMessage {
  return {
    id: id || nanoid(),
    role: 'user',
    parts: [{ type: 'text', text: content }]
  };
}

/**
 * Create an assistant message in UIMessage format
 */
export function createAssistantMessage(content: string, id?: string): UIMessage {
  return {
    id: id || nanoid(),
    role: 'assistant',
    parts: [{ type: 'text', text: content }]
  };
}

/**
 * Create a tool call message
 * Note: Tool calls are typically generated by the AI, not manually created
 * This is a simplified version for testing purposes
 */
export function createToolCallMessage(
  toolName: string,
  toolCallId: string,
  args: Record<string, any>
): any {
  return {
    id: nanoid(),
    role: 'assistant',
    parts: [
      {
        type: 'tool-call' as const,
        toolCallId,
        toolName,
        args
      } as any
    ]
  };
}

/**
 * Create a tool result message
 * Note: Tool results are typically generated by tool execution, not manually
 * This is a simplified version for testing purposes
 */
export function createToolResultMessage(
  toolCallId: string,
  toolName: string,
  result: any
): any {
  return {
    id: nanoid(),
    role: 'tool',
    parts: [
      {
        type: 'tool-result' as const,
        toolCallId,
        toolName,
        result
      } as any
    ]
  };
}

/**
 * Make a POST request to an API endpoint
 */
export async function postToAPI(
  endpoint: string,
  body: any,
  options?: {
    userId?: string;
    queryParams?: Record<string, string>;
    headers?: Record<string, string>;
  }
) {
  const { userId, queryParams, headers = {} } = options || {};

  // Build URL with query params
  const url = new URL(endpoint, 'http://localhost:3000');
  if (queryParams) {
    Object.entries(queryParams).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });
  }

  const response = await fetch(url.toString(), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...(userId ? { 'x-user-id': userId } : {}),
      ...headers
    },
    body: JSON.stringify(body)
  });

  return response;
}

/**
 * Read a streaming response
 */
export async function readStreamingResponse(response: Response): Promise<string[]> {
  if (!response.body) {
    throw new Error('No response body');
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  const chunks: string[] = [];

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      chunks.push(chunk);
    }
  } finally {
    reader.releaseLock();
  }

  return chunks;
}

/**
 * Parse streaming chunks into data events
 */
export function parseStreamingChunks(chunks: string[]): any[] {
  const events: any[] = [];
  const fullText = chunks.join('');

  // Split by data: prefix and parse each JSON object
  const lines = fullText.split('\n');

  for (const line of lines) {
    if (line.startsWith('data: ')) {
      const jsonStr = line.slice(6).trim();
      if (jsonStr && jsonStr !== '[DONE]') {
        try {
          events.push(JSON.parse(jsonStr));
        } catch (e) {
          // Skip invalid JSON
        }
      }
    }
  }

  return events;
}

/**
 * Wait for a condition to be true with timeout
 */
export async function waitFor(
  condition: () => boolean | Promise<boolean>,
  options?: {
    timeout?: number;
    interval?: number;
  }
): Promise<void> {
  const { timeout = 5000, interval = 100 } = options || {};
  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    if (await condition()) {
      return;
    }
    await new Promise(resolve => setTimeout(resolve, interval));
  }

  throw new Error(`Condition not met within ${timeout}ms`);
}

/**
 * Create a sample MCP server config (SSE)
 */
export function createMCPServerConfig(
  url: string,
  type: 'sse' | 'stdio' = 'sse'
) {
  if (type === 'sse') {
    return {
      url,
      type: 'sse' as const,
      headers: []
    };
  }

  // For stdio (example)
  return {
    url: '',
    type: 'stdio' as const,
    command: 'python3',
    args: ['-m', 'example_mcp_server'],
    env: []
  };
}

/**
 * Extract text content from streaming events
 */
export function extractTextFromEvents(events: any[]): string {
  let text = '';

  for (const event of events) {
    if (event.type === 'text-delta' && event.delta) {
      text += event.delta;
    }
  }

  return text;
}

/**
 * Extract tool calls from streaming events
 */
export function extractToolCallsFromEvents(events: any[]): any[] {
  const toolCalls: any[] = [];

  for (const event of events) {
    if (event.type === 'tool-call' || event.type === 'tool-call-delta') {
      toolCalls.push(event);
    }
  }

  return toolCalls;
}

/**
 * Check if response is a valid streaming response
 */
export function isStreamingResponse(response: Response): boolean {
  const contentType = response.headers.get('content-type');
  return contentType?.includes('text/event-stream') || false;
}

/**
 * Validate UIMessage structure
 */
export function isValidUIMessage(message: any): message is UIMessage {
  return (
    message &&
    typeof message === 'object' &&
    typeof message.id === 'string' &&
    typeof message.role === 'string' &&
    Array.isArray(message.parts) &&
    message.parts.every((part: any) =>
      part && typeof part === 'object' && typeof part.type === 'string'
    )
  );
}
